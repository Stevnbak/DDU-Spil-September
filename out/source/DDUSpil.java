/* autogenerated by Processing revision 1286 on 2022-09-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class DDUSpil extends PApplet {

PVector camLocation;
float camSpeed = 20;
public Player player = new Player();
public level currentLevel = new level();

public HashMap<String, Boolean> inputs = new HashMap<String, Boolean>();

staticObject[] objects = new staticObject[2];
dynamicObject[] dynamicObjects = new dynamicObject[1];

 public void setup() {
  /* size commented out by preprocessor */;
  surface.setTitle("Game Title");
  surface.setResizable(true);
  camLocation = new PVector(0, 0);
  objects[0] = new staticObject(new PVector(0, height), new PVector(width * 2000, 50));
  objects[1] = new staticObject(new PVector(width / 2, height - 50), new PVector(200, 500));

  dynamicObjects[0] = new testObject();
}

 public void updateCamLocation() {
  PVector centerLocation = new PVector(camLocation.x + width/2, camLocation.y + height /2);
  float xDistance = centerLocation.x - player.location.x;
  float yDistance = centerLocation.y - player.location.y;
  camLocation.x -= xDistance / camSpeed;
  camLocation.y -= yDistance / camSpeed;
}

// Inputs
public Boolean getInput(String keyValue)
{
  return inputs.getOrDefault(keyValue, false);
}
 public void keyPressed() {
  inputs.put(key + "", true);
}
 public void keyReleased() {
  inputs.put(key + "", false);
}
 public void mousePressed() {
  switch (mouseButton) {
  case 37:
    {
      inputs.put("MLeft", true);
      break;
    }
  case 39:
    {
      inputs.put("MRight", true);
      break;
    }
  case 3:
    {
      inputs.put("MMid", true);
      break;
    }
  }
}
 public void mouseReleased() {
  switch (mouseButton) {
  case 37:
    {
      inputs.put("MLeft", false);
      break;
    }
  case 39:
    {
      inputs.put("MRight", false);
      break;
    }
  case 3:
    {
      inputs.put("MMid", false);
      break;
    }
  }
}

//Draw
 public void draw() {
    for (int i = 0; i < dynamicObjects.length; i++) {
    dynamicObjects[i].physics();
  }
  player.update();
  for (int i = 0; i < objects.length; i++) {
    objects[i].update();
  }

  background(255);
  updateCamLocation();
  rectMode(CENTER);
  translate(-camLocation.x, -camLocation.y);
  for (int i = 0; i < dynamicObjects.length; i++) {
    dynamicObjects[i].draw();
  }
  for (int i = 0; i < objects.length; i++) {
    objects[i].draw();
  }
  player.draw();
}
class dynamicObject {
  PVector location = new PVector(100, 100);
  PVector velocity = new PVector(0, 0);
  PVector acceleration = new PVector(0, 0);
  PVector size = new PVector(20, 20);
  float mass, airConstant, maxVelocity = -1;

   public void draw() {
    //Update location...
    velocity.add(acceleration.mult(mass));
    if (maxVelocity > -1) {
      velocity.x = constrain(velocity.x, -maxVelocity, maxVelocity);
      velocity.y = constrain(velocity.y, -maxVelocity, maxVelocity);
    }
    location.add(velocity);
  }

  //Add force to object function
   public void addForce(PVector force) {
    //print("Force added: " + force);
    acceleration.add(new PVector(force.x / mass, force.y / mass));
    //print("New total acceleration: " + acceleration + "\n");
  }

  //Reset object acceleration
   public void resetAccel() {
    //print("Frame start \n");
    acceleration = new PVector(0, 0);
  }
  //Physics
   public void physics() {
    resetAccel();
    gravity();
    wind();
    airResistance();
  }

  //Gravity
   public void gravity() {
    PVector gravity = new PVector(0, 1);
    addForce(gravity);
  }

  //Air resistance
   public void airResistance() {
    PVector drag = velocity.get();
    float speed = drag.mag();
    float area = size.y;
    float magnitude = (speed * (area / 500)) * airConstant;
    drag.mult(-1);
    drag.normalize();
    drag.mult(magnitude);
    //print("\nSpeed: " + speed + "\nArea:" + area + "\nMagnitude: " + magnitude + "\nLuftmodstand: " + drag);
    addForce(drag);
  }

  //Wind
   public void wind() {
    PVector wind = currentLevel.wind;
    print("\nWind:" + wind);
    addForce(wind.get());
  }

  //Friction function
  PVector lastFriction = new PVector(0, 0, 0);
   public void friction(float frictionC, float axis) {
    //print("Velocity (Friction): " + velocity + "\n");
    float normal = 1;
    float frictionMag = frictionC * normal;
    PVector friction = velocity.get();
    friction.mult(-1);
    friction.normalize();
    friction.mult(frictionMag);
    if (-lastFriction.x == friction.x) {
      lastFriction = friction.get();
      friction.x = 0;
    }
    if (-lastFriction.y == friction.y) {
      lastFriction = friction.get();
      friction.y = 0;
    }
    if (axis == 0) friction.y = 0;
    if (axis == 1) friction.x = 0;
    //print("Friction: " + friction + "\n");
    addForce(friction);
  }
  //Drag in liquid
   public void drag(float dragConstant) {
    PVector drag = velocity.get();
    float speed = drag.mag();
    float dragMag = dragConstant * speed * speed * (size.x * size.y / 20);
    drag.mult(-1);
    drag.normalize();
    drag.mult(dragMag);
    //print("Drag: " + drag + "\n");
    addForce(drag);
  }


  //Collisions...
  //Bounce function
   public void bounce(float locationValue, float axis) {
    if (axis == 0) {
      location.x = locationValue;
      velocity.x = 0;
    }
    if (axis == 1) {
      location.y = locationValue;
      velocity.y = 0;
    }
  }
   public void boxCollision(float x, float y, float w, float h, float frictionC) {
    //Y-Collision
    if (location.x + (size.x / 2) >= x && location.x - (size.x / 2) <= x + w) {
      //Bottom
      if (location.y - (size.y / 2) <= y + h && location.y + (size.y / 2) >= y + h) {
        bounce( y + h + (size.y / 2), 1);
        friction(frictionC, 0);
      }
      //Top
      if (location.y + (size.y / 2) >= y && location.y - (size.y / 2) <= y) {
        bounce(y - (size.y / 2), 1);
        friction(frictionC, 0);
      }
    }
    //X-Collision
    if (location.y + (size.y / 2) - 1 >= y && location.y - (size.y / 2) + 1 <= y + h) {
      //Left
      if (location.x + (size.x / 2) >= x && location.x - (size.x / 2) <= x) {
        bounce(x - (size.x / 2), 0);
        friction(frictionC, 1);
      }
      //Right
      if (location.x - (size.x / 2) <= x + w && location.x + (size.x / 2) >= x + w) {
        bounce( x + w + (size.x / 2), 0);
        friction(frictionC, 1);
      }
    }
  }
}

class testObject extends dynamicObject {
  testObject() {
    mass = 0.5f;
    airConstant = 0.2f;
    maxVelocity = 10;
  }
   public void draw() {
    super.draw();
    noStroke();
    colorMode(RGB);
    fill(60, 120, 60);
    rect(location.x, location.y, size.x, size.y);
    //print("\nLocation: " + location);
  }
}
class level {
  PVector wind = new PVector(0.075f, 0);
}
class Player extends dynamicObject {
  //Object definitions
  float standardAccel = 0.25f, jumpPower = 25;
  boolean isTouchingGround = false;

  //Textures
  PImage playerTexture;

  Player() {
    mass = 5;
    maxVelocity = 10;
    airConstant = 0;
    size = new PVector(60, 97);
  }

  //Color value
  PVector colorValue = new PVector(2, 230, 36);

   public void update() {
    physics();
    //Textures
    animations();

    //Inputs
    if (getInput("a")) {
      addForce(new PVector(-standardAccel, 0));
    }
    if (getInput("d")) {
      addForce(new PVector(standardAccel, 0));
    }
    if (getInput("w") || getInput(" ")) {
      if (isTouchingGround) addForce(new PVector(0, -jumpPower));
    }
    isTouchingGround = false;
  }

  int frameTime = 0, anim = 2;

   public void animations() {
    if (isTouchingGround == false) {
      if (velocity.y < 0) {
        playerTexture = loadImage("player_jump.png");
      } else {
        playerTexture = loadImage("player_fall.png");
      }
    } else if (velocity.x < -0.2f || velocity.x > 0.2f) {
      if (frameTime < millis()) {
        if (anim == 1) anim = 2;
        else if (anim == 2) anim =1;
        playerTexture = loadImage("player_walk" + anim+ ".png");
        frameTime = millis() + 100;
      }
    } else {
      playerTexture = loadImage("player_stand.png");
    }
  }

  float c1 = 0, c2 = 1, c3 = 1, c4 = 0;
   public void draw() {
    super.draw();
    noStroke();
    colorMode(RGB);
    textureMode(NORMAL);
    beginShape();
    texture(playerTexture);
    if (getInput("d")) {
      c1 = 0;
      c2 = 1;
      c3 = 1;
      c4 = 0;
    } else if (getInput("a")) {
      c1 = 1;
      c2 = 0;
      c3 = 0;
      c4 = 1;
    }
    vertex(location.x - size.x/2, location.y - size.y/2, c1, 0);
    vertex(location.x + size.x/2, location.y - size.y/2, c2, 0);
    vertex(location.x + size.x/2, location.y + size.y/2, c3, 1);
    vertex(location.x - size.x/2, location.y + size.y/2, c4, 1);
    endShape();
  }

  //Bounce function
   public void bounce(float locationValue, float axis) {
    super.bounce(locationValue, axis);
    if (axis == 1) {
      isTouchingGround = true;
    }
  }
}
class staticObject {
  //Object definitions
  PVector size;
  float frictionC = 0.15f;
  //Loction vector
  PVector location = new PVector(0, 0);

  //Constructor
  staticObject(PVector startLocation, PVector newSize) {
    location = startLocation.get();
    size = newSize.get();
  }

  //Update
   public void update() {
    //Collision check
    collisionCheck();
  }

   public void collisionCheck() {
    for (int i = 0; i < dynamicObjects.length; i++) {
      dynamicObjects[i].boxCollision(location.x - size.x / 2, location.y - size.y/2, size.x, size.y, frictionC);
    }
    player.boxCollision(location.x - size.x / 2, location.y - size.y/2, size.x, size.y, frictionC);
  }

   public void draw() {
    stroke(0);
    colorMode(RGB);
    fill(252, 61, 3);
    rect(location.x, location.y, size.x, size.y);
  }
}


  public void settings() { size(1080, 720, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "DDUSpil" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
