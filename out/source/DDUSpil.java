/* autogenerated by Processing revision 1286 on 2022-09-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class DDUSpil extends PApplet {

PVector camLocation;
float camSpeed = 20;
public Player player = new Player();
public level currentLevel = new level();

public HashMap<String, Boolean> inputs = new HashMap<String, Boolean>();

staticObject[] objects = new staticObject[2];
dynamicObject[] testObjects = new dynamicObject[1];

 public void setup() {
  /* size commented out by preprocessor */;
  surface.setTitle("Game Title");
  surface.setResizable(true);
  camLocation = new PVector(0, 0);
  objects[0] = new staticObject(new PVector(0, height), new PVector(width * 2000, 50));
  objects[1] = new staticObject(new PVector(width / 2, height - 50), new PVector(200, 500));

  testObjects[0] = new testObject();
}

 public void updateCamLocation() {
  PVector centerLocation = new PVector(camLocation.x + width/2, camLocation.y + height /2);
  float xDistance = centerLocation.x - player.location.x;
  float yDistance = centerLocation.y - player.location.y;
  camLocation.x -= xDistance / camSpeed;
  camLocation.y -= yDistance / camSpeed;
}

// Inputs
public Boolean getInput(String keyValue)
{
  return inputs.getOrDefault(keyValue, false);
}
 public void keyPressed() {
  inputs.put(key + "", true);
}
 public void keyReleased() {
  inputs.put(key + "", false);
}
 public void mousePressed() {
  switch (mouseButton) {
  case 37:
    {
      inputs.put("MLeft", true);
      break;
    }
  case 39:
    {
      inputs.put("MRight", true);
      break;
    }
  case 3:
    {
      inputs.put("MMid", true);
      break;
    }
  }
}
 public void mouseReleased() {
  switch (mouseButton) {
  case 37:
    {
      inputs.put("MLeft", false);
      break;
    }
  case 39:
    {
      inputs.put("MRight", false);
      break;
    }
  case 3:
    {
      inputs.put("MMid", false);
      break;
    }
  }
}

//Physics
 public void physics() {
  player.resetAccel();
  gravity(player);
  wind(player);
  airResistance(player);
}

//Gravity
 public void gravity(dynamicObject object) {
  PVector gravity = new PVector(0, 1);
  object.addForce(gravity);
}

//Air resistance
 public void airResistance(dynamicObject object) {
  PVector drag = object.velocity.get();
  float speed = drag.mag();
  float area = object.size.y;
  float magnitude = (speed * (area / 500)) * object.airConstant;
  drag.mult(-1);
  drag.normalize();
  drag.mult(magnitude);
  //print("\nSpeed: " + speed + "\nArea:" + area + "\nMagnitude: " + magnitude + "\nLuftmodstand: " + drag);
  object.addForce(drag);
}

//Wind
 public void wind(dynamicObject object) {
  PVector wind = currentLevel.wind;
  object.addForce(wind.div(10));
}

//Draw
 public void draw() {
  physics();
  for (int i = 0; i < objects.length; i++) {
    objects[i].update();
  }
  player.update();

  background(255);
  updateCamLocation();
  rectMode(CENTER);
  translate(-camLocation.x, -camLocation.y);

  for (int i = 0; i < objects.length; i++) {
    objects[i].draw();
  }
  player.draw();
}
class dynamicObject {
  PVector location = new PVector(0, 0);
  PVector velocity = new PVector(0, 0);
  PVector acceleration = new PVector(0, 0);
  PVector size = new PVector(20, 20);
  float mass, airConstant;

  //Add force to object function
   public void addForce(PVector force) {
    //print("Force added: " + force);
    acceleration.add(new PVector(force.x / mass, force.y / mass));
    //print("New total acceleration: " + acceleration + "\n");
  }

  //Reset object acceleration
   public void resetAccel() {
    //print("Frame start \n");
    acceleration = new PVector(0, 0);
  }

   public void draw() {
    registerMethod("draw", this);
  }
}

class testObject extends dynamicObject {
    testObject() {
        mass = 0.5f;
        airConstant = 0.2f;

    }
     public void draw() {
        //registerMethod("draw", this);
        super.draw();
        noStroke();
        colorMode(RGB);
        fill(60, 120, 60);
        rect(location.x, location.y, size.x, size.y);
        print("\nLocation: " + location);
    }
}
class level {
    PVector wind = new PVector(5,0);
}
class Player extends dynamicObject {
  //Object definitions
  float bounceFactor = random(0.850f, 0.950f), standardAccel = 0.25f, jumpPower = 15, maxVelocity = 10;
  boolean isTouchingGround = false;

  //Textures
  PImage playerTexture;

  Player() {
    mass = 5;
    airConstant = 0;
    size = new PVector(60, 97);
  }

  //Color value
  PVector colorValue = new PVector(2, 230, 36);

   public void update() {
    //Textures
    animations();

    //Inputs
    if (getInput("a")) {
      addForce(new PVector(-standardAccel, 0));
    }
    if (getInput("d")) {
      addForce(new PVector(standardAccel, 0));
    }
    if (getInput("w") || getInput(" ")) {
      if (isTouchingGround) addForce(new PVector(0, -jumpPower));
    }

    //Update location...
    velocity.add(acceleration.mult(mass));
    velocity.x = constrain(velocity.x, -maxVelocity, maxVelocity);
    location.add(velocity);
    isTouchingGround = false;
  }

   public void animations() {
    playerTexture = loadImage("player.png");
  }

  float c1 = 0,c2 = 1,c3 = 1,c4 = 0;
   public void draw() {
    noStroke();
    colorMode(RGB);
    /*
    float dir = 1;
    if (velocity.x > 0.1) {
      dir = 1;
      scale(1,1);
    } else if (velocity.x < -0.1) {
      dir = -1;
      scale(-1,1);
    }*/
    //fill(60, 120, 60);
    //rect(location.x, location.y, size.x, size.y);
    textureMode(NORMAL);
    beginShape();
    texture(playerTexture);
    if (getInput("a")) {
      c1 = 0;
      c2 = 1;
      c3 = 1;
      c4 = 0;
      
    } else if(getInput("d")) {
      c1 = 1;
      c2 = 0;
      c3 = 0;
      c4 = 1;
    }
    vertex(location.x - size.x/2, location.y - size.y/2, c1, 0);
    vertex(location.x + size.x/2, location.y - size.y/2, c2, 0);
    vertex(location.x + size.x/2, location.y + size.y/2, c3, 1);
    vertex(location.x - size.x/2, location.y + size.y/2, c4, 1);
    endShape();
  }

  //Friction function
  PVector lastFriction = new PVector(0, 0, 0);
   public void friction(float frictionC, float axis) {
    //print("Velocity (Friction): " + velocity + "\n");
    float normal = 1;
    float frictionMag = frictionC * normal;
    PVector friction = velocity.get();
    friction.mult(-1);
    friction.normalize();
    friction.mult(frictionMag);
    if (-lastFriction.x == friction.x) {
      lastFriction = friction.get();
      friction.x = 0;
    }
    if (-lastFriction.y == friction.y) {
      lastFriction = friction.get();
      friction.y = 0;
    }
    if (axis == 0) friction.y = 0;
    if (axis == 1) friction.x = 0;
    //print("Friction: " + friction + "\n");
    addForce(friction);
  }
  //Drag in liquid
   public void drag(float dragConstant) {
    PVector drag = velocity.get();
    float speed = drag.mag();
    float dragMag = dragConstant * speed * speed * (size.x * size.y / 20);
    drag.mult(-1);
    drag.normalize();
    drag.mult(dragMag);
    //print("Drag: " + drag + "\n");
    addForce(drag);
  }


  //Collisions...
  //Bounce function
   public void bounce(float locationValue, float axis) {
    if (axis == 0) {
      location.x = locationValue;
      velocity.x = 0;
      //velocity.x *= -bounceFactor;
      //if(velocity.x > 1) velocity.x = round(velocity.x);
    }
    if (axis == 1) {
      location.y = locationValue;
      velocity.y = 0;
      isTouchingGround = true;
      //velocity.y *= -bounceFactor;
      //if(velocity.y > 1) velocity.y = round(velocity.y);
    }
  }
   public void boxCollision(float x, float y, float w, float h, float friction) {
    //Y-Collision
    if (location.x + (size.x / 2) >= x && location.x - (size.x / 2) <= x + w) {
      //Bottom
      if (location.y - (size.y / 2) <= y + h && location.y + (size.y / 2) >= y + h) {
        bounce( y + h + (size.y / 2), 1);
        friction(friction, 0);
      }
      //Top
      if (location.y + (size.y / 2) >= y && location.y - (size.y / 2) <= y) {
        bounce(y - (size.y / 2), 1);
        friction(friction, 0);
      }
    }
    //X-Collision
    if (location.y + (size.y / 2) - 5 >= y && location.y - (size.y / 2) + 5 <= y + h) {
      //Left
      if (location.x + (size.x / 2) >= x && location.x - (size.x / 2) <= x) {
        bounce(x - (size.x / 2), 0);
        friction(friction, 1);
      }
      //Right
      if (location.x - (size.x / 2) <= x + w && location.x + (size.x / 2) >= x + w) {
        bounce( x + w + (size.x / 2), 0);
        friction(friction, 1);
      }
    }
  }
}
class staticObject {
  //Object definitions
  PVector size;
  float frictionC = 0.15f;
  //Loction vector
  PVector location = new PVector(0, 0);

  //Constructor
  staticObject(PVector startLocation, PVector newSize) {
    location = startLocation.get();
    size = newSize.get();
  }

  //Update
   public void update() {
    //Collision check
    collisionCheck();
  }

   public void collisionCheck() {
    player.boxCollision(location.x - size.x / 2, location.y - size.y/2, size.x, size.y, frictionC);
  }

   public void draw() {
    stroke(0);
    colorMode(RGB);
    fill(252, 61, 3);
    rect(location.x, location.y, size.x, size.y);
  }
}


  public void settings() { size(1080, 720, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "DDUSpil" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
